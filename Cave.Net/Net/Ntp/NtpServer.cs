using System;
using Cave.IO;

namespace Cave.Net.Ntp
{
    /// <summary>Implements a rfc2030 ntp server. All incoming udp packets at port 123 are answered using values generated by the <see cref="PropertiesFunction"/>.</summary>
    public class NtpServer : UdpServer
    {
        #region Private Classes

        class DefaultNtpProperties : INtpServerProperties
        {
            #region Public Properties

            public DateTime DateTime => DateTime.Now;
            public NtpPow2Int8 PollInterval => 6;
            public NtpPow2Int8 Precision => -1;
            public NtpUInt32 Reference => (uint)FourCC.FromString("LOCL");
            public NtpTimestamp ReferenceTimestamp => DateTime.Now;
            public NtpFixedPointInt32 RootDelay => 1 << 16;
            public NtpFixedPointUInt32 RootDispersion => 1 << 16;
            public byte Stratum => 0x3e;
            public bool Valid => true;

            #endregion Public Properties
        }

        #endregion Private Classes

        #region Private Fields

        Func<INtpServerProperties> propertiesFunction = () => new DefaultNtpProperties();

        #endregion Private Fields

        #region Private Methods

        bool Handle(UdpPacket packet)
        {
            var properties = propertiesFunction();
            var request = MarshalStruct.GetStruct<NtpPacket>(packet.Data);
            if (!OnRequest(ref request))
            {
                return false;
            }

            var answer = request;
            var multicast = false;
            answer.LeapIndicator = properties.Valid ? NtpLeapIndicator.NoWarning : NtpLeapIndicator.Alarm;
            switch (request.Mode)
            {
                case NtpMode.Client:
                {
                    answer.Mode = NtpMode.Server;
                    break;
                }

                default:
                {
                    multicast = packet.RemoteEndPoint.Address.IsMulticast();
                    answer.Mode = NtpMode.SymmetricPassive;
                    if (multicast)
                    {
                        answer.VersionNumber = 4;
                        answer.Mode = NtpMode.Broadcast;
                        answer.PollInterval = 6;
                    }

                    break;
                }
            }

            answer.Stratum = properties.Stratum;
            answer.PollInterval = properties.PollInterval;
            answer.Precision = properties.Precision;
            answer.RootDelay = properties.RootDelay;
            answer.RootDispersion = properties.RootDispersion;
            answer.Reference = properties.Reference;
            answer.ReferenceTimestamp = properties.ReferenceTimestamp;
            answer.TransmitTimestamp = properties.DateTime;
            if (multicast)
            {
                answer.OriginateTimestamp = NtpTimestamp.Zero;
                answer.ReceiveTimestamp = NtpTimestamp.Zero;
            }
            else
            {
                answer.OriginateTimestamp = request.TransmitTimestamp;
                answer.ReceiveTimestamp = properties.DateTime;
            }

            if (!OnAnswer(ref answer))
            {
                return false;
            }

            MarshalStruct.Write(answer, packet.Data, 0);
            return true;
        }

        #endregion Private Methods

        #region Protected Methods

        /// <summary>Calls the <see cref="Answer"/> event and returns whether the answer shall be sent (true) or not (false).</summary>
        /// <param name="answer">Answer packet.</param>
        /// <returns>Returns whether the answer shall be sent (true) or not (false).</returns>
        protected virtual bool OnAnswer(ref NtpPacket answer)
        {
            var handler = Answer;
            //has handler ?
            if (handler != null)
            {
                //call handler
                var e = new NtpPacketEventArgs(answer);
                handler.Invoke(this, e);
                //handle ?
                if (!e.Discard)
                {
                    answer = e.Packet;
                    return false;
                }
            }
            return true;
        }

        /// <summary>Calls the base function, then handles the incoming packet.</summary>
        /// <param name="packet">The received udp packet.</param>
        protected override void OnReceived(UdpPacket packet)
        {
            base.OnReceived(packet);
            if (Handle(packet))
            {
                Send(packet);
            }
        }

        /// <summary>Calls the <see cref="Request"/> event and returns whether the request shall be handled (true) or not (false).</summary>
        /// <param name="request">Request packet.</param>
        /// <returns>Returns whether the request shall be handled (true) or not (false).</returns>
        protected virtual bool OnRequest(ref NtpPacket request)
        {
            var handler = Request;
            //has handler ?
            if (handler != null)
            {
                //call handler
                var e = new NtpPacketEventArgs(request);
                handler.Invoke(this, e);
                //handle ?
                if (!e.Discard)
                {
                    request = e.Packet;
                    return false;
                }
            }
            return true;
        }

        #endregion Protected Methods

        #region Public Fields

        /// <summary>Event to be called on each outgoing answer (before sending).</summary>
        public EventHandler<NtpPacketEventArgs> Answer;

        /// <summary>Event to be called on each incoming request (before handling).</summary>
        public EventHandler<NtpPacketEventArgs> Request;

        #endregion Public Fields

        #region Public Properties

        /// <summary>Gets or sets the <see cref="Func{INtpServerProperties}"/> used to retrieve the answer values.</summary>
        public Func<INtpServerProperties> PropertiesFunction { get => propertiesFunction; set => propertiesFunction = value ?? throw new ArgumentNullException(nameof(value)); }

        #endregion Public Properties
    }
}
